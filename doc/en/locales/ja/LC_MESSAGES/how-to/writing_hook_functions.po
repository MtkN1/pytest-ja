# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, holger krekel and pytest-dev team
# This file is distributed under the same license as the pytest package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pytest 0.1.dev16209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-05 00:52+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../how-to/writing_hook_functions.rst:4
msgid "Writing hook functions"
msgstr "フック関数の記述"

#: ../../how-to/writing_hook_functions.rst:10
msgid "hook function validation and execution"
msgstr "フック関数の検証と実行"

#: ../../how-to/writing_hook_functions.rst:12
msgid "pytest calls hook functions from registered plugins for any given hook specification.  Let's look at a typical hook function for the ``pytest_collection_modifyitems(session, config, items)`` hook which pytest calls after collection of all test items is completed."
msgstr "pytest は、登録されたプラグインから任意のフックスペックに対してフック関数を呼び出します。ここでは、すべてのテストアイテムの収集後に pytest が呼び出す ``pytest_collection_modifyitems(session, config, items)`` フックの典型的なフック関数を見てみましょう。"

#: ../../how-to/writing_hook_functions.rst:18
msgid "When we implement a ``pytest_collection_modifyitems`` function in our plugin pytest will during registration verify that you use argument names which match the specification and bail out if not."
msgstr "プラグイン内で ``pytest_collection_modifyitems`` 関数を実装する場合、pytest は登録時に引数名が仕様と一致しているか検証し、一致しなければ処理を中断します。"

#: ../../how-to/writing_hook_functions.rst:22
msgid "Let's look at a possible implementation:"
msgstr "考えられる実装例を見てみましょう："

#: ../../how-to/writing_hook_functions.rst:31
msgid "Here, ``pytest`` will pass in ``config`` (the pytest config object) and ``items`` (the list of collected test items) but will not pass in the ``session`` argument because we didn't list it in the function signature.  This dynamic \"pruning\" of arguments allows ``pytest`` to be \"future-compatible\": we can introduce new hook named parameters without breaking the signatures of existing hook implementations.  It is one of the reasons for the general long-lived compatibility of pytest plugins."
msgstr "ここでは、``pytest`` は ``config`` (pytest の設定オブジェクト) と ``items`` (収集されたテストアイテムのリスト) を渡しますが、関数シグネチャに ``session`` を記載していないため、``session`` 引数は渡されません。この動的な引数の「剪定」により、``pytest`` は「将来互換性」を保つことが可能になり、新しいフックの名前付きパラメータを既存のフック実装のシグネチャを壊すことなく追加できます。これが pytest プラグインの互換性が長期間維持される理由の一つです。"

#: ../../how-to/writing_hook_functions.rst:39
msgid "Note that hook functions other than ``pytest_runtest_*`` are not allowed to raise exceptions.  Doing so will break the pytest run."
msgstr "``pytest_runtest_*`` 以外のフック関数で例外を投げることは許可されていません。そうすると pytest の実行が中断します。"

#: ../../how-to/writing_hook_functions.rst:47
msgid "firstresult: stop at first non-None result"
msgstr "firstresult：最初の None でない結果で停止"

#: ../../how-to/writing_hook_functions.rst:49
msgid "Most calls to ``pytest`` hooks result in a **list of results** which contains all non-None results of the called hook functions."
msgstr "ほとんどの ``pytest`` フック呼び出しは、呼び出されたすべての非 None 結果を含む **結果のリスト** を返します。"

#: ../../how-to/writing_hook_functions.rst:52
msgid "Some hook specifications use the ``firstresult=True`` option so that the hook call only executes until the first of N registered functions returns a non-None result which is then taken as result of the overall hook call. The remaining hook functions will not be called in this case."
msgstr "一部のフックスペックでは ``firstresult=True`` オプションが使用され、N 個の登録された関数のうち最初の非 None 結果が返された時点で全体のフック呼び出しの結果としてその値が採用され、残りのフック関数は呼び出されません。"

#: ../../how-to/writing_hook_functions.rst:60
msgid "hook wrappers: executing around other hooks"
msgstr "フックラッパー：他のフックの前後で実行"

#: ../../how-to/writing_hook_functions.rst:62
msgid "pytest plugins can implement hook wrappers which wrap the execution of other hook implementations.  A hook wrapper is a generator function which yields exactly once. When pytest invokes hooks it first executes hook wrappers and passes the same arguments as to the regular hooks."
msgstr "pytest プラグインは、他のフック実装をラップするフックラッパーを実装できます。フックラッパーは、正確に1度 yield するジェネレーター関数です。pytest がフックを呼び出すとき、最初にフックラッパーを実行し、通常のフックと同じ引数を渡します。"

#: ../../how-to/writing_hook_functions.rst:67
msgid "At the yield point of the hook wrapper pytest will execute the next hook implementations and return their result to the yield point, or will propagate an exception if they raised."
msgstr "フックラッパーの yield の箇所で、pytest は次のフック実装を実行し、その結果を yield に返すか、例外が発生した場合はその例外を伝搬させます。"

#: ../../how-to/writing_hook_functions.rst:71
msgid "Here is an example definition of a hook wrapper:"
msgstr "フックラッパーの定義例は次の通りです："

#: ../../how-to/writing_hook_functions.rst:90
msgid "The hook wrapper needs to return a result for the hook, or raise an exception."
msgstr "フックラッパーはフックのための結果を返すか、例外を発生させる必要があります。"

#: ../../how-to/writing_hook_functions.rst:92
msgid "In many cases, the wrapper only needs to perform tracing or other side effects around the actual hook implementations, in which case it can return the result value of the ``yield``. The simplest (though useless) hook wrapper is ``return (yield)``."
msgstr "多くの場合、ラッパーは実際のフック実装の周りでトレースや他の副作用を実行するだけでよく、その場合、``yield`` の結果値を返すことができます。最も単純 (だが無意味) なフックラッパーは ``return (yield)`` です。"

#: ../../how-to/writing_hook_functions.rst:97
msgid "In other cases, the wrapper wants the adjust or adapt the result, in which case it can return a new value. If the result of the underlying hook is a mutable object, the wrapper may modify that result, but it's probably better to avoid it."
msgstr "他の場合では、ラッパーは結果を調整または適応させたい場合があり、その場合、新しい値を返すことができます。基礎となるフックの結果が可変オブジェクトである場合、ラッパーはその結果を変更することがありますが、避けた方が良いでしょう。"

#: ../../how-to/writing_hook_functions.rst:101
msgid "If the hook implementation failed with an exception, the wrapper can handle that exception using a ``try-catch-finally`` around the ``yield``, by propagating it, suppressing it, or raising a different exception entirely."
msgstr "フック実装が例外で失敗した場合、ラッパーは ``yield`` の周りで ``try-catch-finally`` を使用してその例外を処理し、伝搬させるか、抑制するか、または完全に異なる例外を発生させることができます。"

#: ../../how-to/writing_hook_functions.rst:105
msgid "For more information, consult the :ref:`pluggy documentation about hook wrappers <pluggy:hookwrappers>`."
msgstr "詳細については、:ref:`フックラッパーに関する pluggy のドキュメント <pluggy:hookwrappers>` を参照してください。"

#: ../../how-to/writing_hook_functions.rst:111
msgid "Hook function ordering / call example"
msgstr "フック関数の順序 / 呼び出し例"

#: ../../how-to/writing_hook_functions.rst:113
msgid "For any given hook specification there may be more than one implementation and we thus generally view ``hook`` execution as a ``1:N`` function call where ``N`` is the number of registered functions. There are ways to influence if a hook implementation comes before or after others, i.e.  the position in the ``N``-sized list of functions:"
msgstr "任意のフックスペックには複数の実装が存在する可能性があり、したがって、``hook`` の実行は ``1:N`` の関数呼び出しと見なされます。ここで ``N`` は登録された関数の数です。フック実装が他の実装の前または後に来るかどうか、つまり ``N`` サイズの関数リスト内の位置に影響を与える方法があります："

#: ../../how-to/writing_hook_functions.rst:145
msgid "Here is the order of execution:"
msgstr "実行順序は次の通りです："

#: ../../how-to/writing_hook_functions.rst:147
msgid "Plugin3's pytest_collection_modifyitems called until the yield point because it is a hook wrapper."
msgstr "Plugin3 の pytest_collection_modifyitems はフックラッパーであるため、yield ポイントまで呼び出されます。"

#: ../../how-to/writing_hook_functions.rst:150
msgid "Plugin1's pytest_collection_modifyitems is called because it is marked with ``tryfirst=True``."
msgstr "Plugin1 の pytest_collection_modifyitems は ``tryfirst=True`` とマークされているため呼び出されます。"

#: ../../how-to/writing_hook_functions.rst:153
msgid "Plugin2's pytest_collection_modifyitems is called because it is marked with ``trylast=True`` (but even without this mark it would come after Plugin1)."
msgstr "Plugin2 の pytest_collection_modifyitems は ``trylast=True`` とマークされているため呼び出されます (ただし、このマークがなくても Plugin1 の後に来ます) 。"

#: ../../how-to/writing_hook_functions.rst:157
msgid "Plugin3's pytest_collection_modifyitems then executing the code after the yield point.  The yield receives the result from calling the non-wrappers, or raises an exception if the non-wrappers raised."
msgstr "その後、Plugin3 の pytest_collection_modifyitems は yield ポイントの後のコードを実行します。yield は非ラッパーの呼び出しから結果を受け取るか、非ラッパーが例外を発生させた場合は例外を発生させます。"

#: ../../how-to/writing_hook_functions.rst:161
msgid "It's possible to use ``tryfirst`` and ``trylast`` also on hook wrappers in which case it will influence the ordering of hook wrappers among each other."
msgstr "フックラッパーにも ``tryfirst`` と ``trylast`` を使用することが可能で、その場合、フックラッパー同士の順序に影響を与えます。"

#: ../../how-to/writing_hook_functions.rst:167
msgid "Declaring new hooks"
msgstr "新しいフックの宣言"

#: ../../how-to/writing_hook_functions.rst:171
msgid "This is a quick overview on how to add new hooks and how they work in general, but a more complete overview can be found in `the pluggy documentation <https://pluggy.readthedocs.io/en/latest/>`__."
msgstr "これは新しいフックの追加方法とその一般的な動作に関する簡単な概要ですが、より完全な概要は `pluggy のドキュメント <https://pluggy.readthedocs.io/en/latest/>`__ にあります。"

#: ../../how-to/writing_hook_functions.rst:174
msgid "Plugins and ``conftest.py`` files may declare new hooks that can then be implemented by other plugins in order to alter behaviour or interact with the new plugin:"
msgstr "プラグインおよび ``conftest.py`` ファイルは、新しいフックを宣言することができ、他のプラグインによって実装されて動作を変更したり、新しいプラグインと対話したりすることができます："

#: _pytest.hookspec.pytest_addhooks:1 of
msgid "Called at plugin registration time to allow adding new hooks via a call to :func:`pluginmanager.add_hookspecs(module_or_class, prefix) <pytest.PytestPluginManager.add_hookspecs>`."
msgstr "プラグイン登録時に呼び出され、:func:`pluginmanager.add_hookspecs(module_or_class, prefix) <pytest.PytestPluginManager.add_hookspecs>` を呼び出して新しいフックを追加できるようにします。"

#: ../../how-to/writing_hook_functions.rst
msgid "Parameters"
msgstr "パラメータ"

#: _pytest.hookspec.pytest_addhooks:4 of
msgid "The pytest plugin manager."
msgstr "pytest プラグインマネージャー。"

#: _pytest.hookspec.pytest_addhooks:7 of
msgid "This hook is incompatible with hook wrappers."
msgstr "このフックはフックラッパーと互換性がありません。"

#: _pytest.hookspec.pytest_addhooks:10 of
msgid "Use in conftest plugins"
msgstr "conftest プラグインでの使用"

#: _pytest.hookspec.pytest_addhooks:12 of
msgid "If a conftest plugin implements this hook, it will be called immediately when the conftest is registered."
msgstr "conftest プラグインがこのフックを実装している場合、conftest が登録されるとすぐに呼び出されます。"

#: ../../how-to/writing_hook_functions.rst:181
msgid "Hooks are usually declared as do-nothing functions that contain only documentation describing when the hook will be called and what return values are expected. The names of the functions must start with `pytest_` otherwise pytest won't recognize them."
msgstr "フックは通常、フックがいつ呼び出されるか、どのような戻り値が期待されるかを説明するドキュメントのみを含む何もしない関数として宣言されます。関数名は `pytest_` で始まらなければなりません。そうでないと pytest はそれらを認識しません。"

#: ../../how-to/writing_hook_functions.rst:185
msgid "Here's an example. Let's assume this code is in the ``sample_hook.py`` module."
msgstr "ここに例があります。このコードが ``sample_hook.py`` モジュールにあると仮定します。"

#: ../../how-to/writing_hook_functions.rst:194
msgid "To register the hooks with pytest they need to be structured in their own module or class. This class or module can then be passed to the ``pluginmanager`` using the ``pytest_addhooks`` function (which itself is a hook exposed by pytest)."
msgstr "フックを pytest に登録するには、それらを独自のモジュールまたはクラスに構造化する必要があります。このクラスまたはモジュールは、``pytest_addhooks`` 関数 (これは pytest によって公開されるフック自体) を使用して ``pluginmanager`` に渡すことができます。"

#: ../../how-to/writing_hook_functions.rst:206
msgid "For a real world example, see `newhooks.py`_ from `xdist <https://github.com/pytest-dev/pytest-xdist>`_."
msgstr "実際の例については、`xdist <https://github.com/pytest-dev/pytest-xdist>`_ の `newhooks.py`_ を参照してください。"

#: ../../how-to/writing_hook_functions.rst:210
msgid "Hooks may be called both from fixtures or from other hooks. In both cases, hooks are called through the ``hook`` object, available in the ``config`` object. Most hooks receive a ``config`` object directly, while fixtures may use the ``pytestconfig`` fixture which provides the same object."
msgstr "フックはフィクスチャから、または他のフックから呼び出される場合があります。いずれの場合も、フックは ``config`` オブジェクト内で利用可能な ``hook`` オブジェクトを通じて呼び出されます。ほとんどのフックは直接 ``config`` オブジェクトを受け取りますが、フィクスチャは同じオブジェクトを提供する ``pytestconfig`` フィクスチャを使用する場合があります。"

#: ../../how-to/writing_hook_functions.rst:223
msgid "Hooks receive parameters using only keyword arguments."
msgstr "フックはキーワード引数のみを使用してパラメータを受け取ります。"

#: ../../how-to/writing_hook_functions.rst:225
msgid "Now your hook is ready to be used. To register a function at the hook, other plugins or users must now simply define the function ``pytest_my_hook`` with the correct signature in their ``conftest.py``."
msgstr "これでフックの準備が整いました。フックに関数を登録するには、他のプラグインやユーザーは、正しいシグネチャを持つ関数 ``pytest_my_hook`` を ``conftest.py`` に定義するだけです。"

#: ../../how-to/writing_hook_functions.rst:228
msgid "Example:"
msgstr "例："

#: ../../how-to/writing_hook_functions.rst:243
msgid "Using hooks in pytest_addoption"
msgstr "pytest_addoption でのフックの使用"

#: ../../how-to/writing_hook_functions.rst:245
msgid "Occasionally, it is necessary to change the way in which command line options are defined by one plugin based on hooks in another plugin. For example, a plugin may expose a command line option for which another plugin needs to define the default value. The pluginmanager can be used to install and use hooks to accomplish this. The plugin would define and add the hooks and use pytest_addoption as follows:"
msgstr "場合によっては、他のプラグインのフックに基づいて、1つのプラグインによって定義されるコマンドラインオプションの方法を変更する必要があります。たとえば、プラグインがコマンドラインオプションを公開し、別のプラグインがそのデフォルト値を定義する必要がある場合があります。pluginmanager を使用してフックをインストールおよび使用してこれを達成できます。プラグインはフックを定義して追加し、次のように pytest_addoption を使用します："

#: ../../how-to/writing_hook_functions.rst:282
msgid "The conftest.py that is using myplugin would simply define the hook as follows:"
msgstr "myplugin を使用している conftest.py は、次のようにフックを定義するだけです："

#: ../../how-to/writing_hook_functions.rst:291
msgid "Optionally using hooks from 3rd party plugins"
msgstr "オプションでサードパーティプラグインのフックを使用する"

#: ../../how-to/writing_hook_functions.rst:293
msgid "Using new hooks from plugins as explained above might be a little tricky because of the standard :ref:`validation mechanism <validation>`: if you depend on a plugin that is not installed, validation will fail and the error message will not make much sense to your users."
msgstr "上記のようにプラグインから新しいフックを使用することは、標準の :ref:`検証メカニズム <validation>` のために少し難しいかもしれません。インストールされていないプラグインに依存している場合、検証は失敗し、エラーメッセージはユーザーにとって意味をなさないでしょう。"

#: ../../how-to/writing_hook_functions.rst:298
msgid "One approach is to defer the hook implementation to a new plugin instead of declaring the hook functions directly in your plugin module, for example:"
msgstr "1つのアプローチは、フック関数をプラグインモジュールに直接宣言するのではなく、新しいプラグインにフック実装を延期することです。たとえば："

#: ../../how-to/writing_hook_functions.rst:317
msgid "This has the added benefit of allowing you to conditionally install hooks depending on which plugins are installed."
msgstr "これには、インストールされているプラグインに応じて条件付きでフックをインストールできるという追加の利点があります。"

#: ../../how-to/writing_hook_functions.rst:323
msgid "Storing data on items across hook functions"
msgstr "フック関数間でアイテムにデータを保存する"

#: ../../how-to/writing_hook_functions.rst:325
msgid "Plugins often need to store data on :class:`~pytest.Item`\\s in one hook implementation, and access it in another. One common solution is to just assign some private attribute directly on the item, but type-checkers like mypy frown upon this, and it may also cause conflicts with other plugins. So pytest offers a better way to do this, :attr:`item.stash <_pytest.nodes.Node.stash>`."
msgstr "プラグインは、1つのフック実装で :class:`~pytest.Item` にデータを保存し、別のフック実装でそれにアクセスする必要があることがよくあります。一般的な解決策は、アイテムにいくつかのプライベート属性を直接割り当てることですが、mypy のような型チェッカーはこれに眉をひそめるかもしれませんし、他のプラグインとの競合を引き起こす可能性もあります。したがって、pytest はこれを行うためのより良い方法を提供します。:attr:`item.stash <_pytest.nodes.Node.stash>`。"

#: ../../how-to/writing_hook_functions.rst:331
msgid "To use the \"stash\" in your plugins, first create \"stash keys\" somewhere at the top level of your plugin:"
msgstr "プラグインで「stash」を使用するには、まずプラグインのトップレベルのどこかに「stash キー」を作成します："

#: ../../how-to/writing_hook_functions.rst:339
msgid "then use the keys to stash your data at some point:"
msgstr "次に、キーを使用してデータを一時保存します："

#: ../../how-to/writing_hook_functions.rst:347
msgid "and retrieve them at another point:"
msgstr "そして、別のポイントでそれらを取得します："

#: ../../how-to/writing_hook_functions.rst:356
msgid "Stashes are available on all node types (like :class:`~pytest.Class`, :class:`~pytest.Session`) and also on :class:`~pytest.Config`, if needed."
msgstr "スタッシュはすべてのノードタイプ (:class:`~pytest.Class`、:class:`~pytest.Session` のような) および必要に応じて :class:`~pytest.Config` でも利用できます。"

