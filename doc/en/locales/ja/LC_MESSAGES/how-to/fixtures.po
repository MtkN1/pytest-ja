# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, holger krekel and pytest-dev team
# This file is distributed under the same license as the pytest package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pytest 0.1.dev16209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-05 00:52+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../how-to/fixtures.rst:4
msgid "How to use fixtures"
msgstr "フィクスチャの使い方"

#: ../../how-to/fixtures.rst:6
msgid ":ref:`about-fixtures`"
msgstr ":ref:`about-fixtures`"

#: ../../how-to/fixtures.rst:7
msgid ":ref:`Fixtures reference <reference-fixtures>`"
msgstr ":ref:`フィクスチャのリファレンス <reference-fixtures>`"

#: ../../how-to/fixtures.rst:11
msgid "\"Requesting\" fixtures"
msgstr "フィクスチャの「リクエスト」"

#: ../../how-to/fixtures.rst:13
msgid "At a basic level, test functions request fixtures they require by declaring them as arguments."
msgstr "基本的なレベルでは、テスト関数は必要なフィクスチャを引数として宣言することでリクエストします。"

#: ../../how-to/fixtures.rst:16
msgid "When pytest goes to run a test, it looks at the parameters in that test function's signature, and then searches for fixtures that have the same names as those parameters. Once pytest finds them, it runs those fixtures, captures what they returned (if anything), and passes those objects into the test function as arguments."
msgstr "pytest がテストを実行するとき、そのテスト関数のシグネチャ内のパラメータを確認し、それらのパラメータと同じ名前のフィクスチャを検索します。pytest がそれらを見つけると、それらのフィクスチャを実行し、返されたもの（もしあれば）をキャプチャし、それらのオブジェクトを引数としてテスト関数に渡します。"

#: ../../how-to/fixtures.rst:24
msgid "Quick example"
msgstr "簡単な例"

#: ../../how-to/fixtures.rst:63
msgid "In this example, ``test_fruit_salad`` \"**requests**\" ``fruit_bowl`` (i.e. ``def test_fruit_salad(fruit_bowl):``), and when pytest sees this, it will execute the ``fruit_bowl`` fixture function and pass the object it returns into ``test_fruit_salad`` as the ``fruit_bowl`` argument."
msgstr "この例では、``test_fruit_salad`` は ``fruit_bowl`` を「**リクエスト**」します（つまり、``def test_fruit_salad(fruit_bowl):``）。pytest がこれを確認すると、``fruit_bowl`` フィクスチャ関数を実行し、返されたオブジェクトを ``test_fruit_salad`` の ``fruit_bowl`` 引数として渡します。"

#: ../../how-to/fixtures.rst:68
msgid "Here's roughly what's happening if we were to do it by hand:"
msgstr "手動で行うと大まかに次のようになります："

#: ../../how-to/fixtures.rst:91
msgid "Fixtures can **request** other fixtures"
msgstr "フィクスチャは他のフィクスチャを **リクエスト** できます"

#: ../../how-to/fixtures.rst:93
msgid "One of pytest's greatest strengths is its extremely flexible fixture system. It allows us to boil down complex requirements for tests into more simple and organized functions, where we only need to have each one describe the things they are dependent on. We'll get more into this further down, but for now, here's a quick example to demonstrate how fixtures can use other fixtures:"
msgstr "pytest の最大の強みの一つは、その非常に柔軟なフィクスチャシステムです。これにより、テストの複雑な要件をよりシンプルで整理された関数にまとめることができ、それぞれが依存しているものを記述するだけで済みます。これについては後ほど詳しく説明しますが、ここではフィクスチャが他のフィクスチャをどのように使用できるかを示す簡単な例を紹介します："

#: ../../how-to/fixtures.rst:125
msgid "Notice that this is the same example from above, but very little changed. The fixtures in pytest **request** fixtures just like tests. All the same **requesting** rules apply to fixtures that do for tests. Here's how this example would work if we did it by hand:"
msgstr "これは上記の例と同じですが、ほとんど変更されていないことに注意してください。pytest のフィクスチャはテストと同様にフィクスチャを **リクエスト** します。テストに適用されるすべての **リクエスト** ルールがフィクスチャにも適用されます。この例を手動で行うと次のようになります："

#: ../../how-to/fixtures.rst:153
msgid "Fixtures are reusable"
msgstr "フィクスチャは再利用可能です"

#: ../../how-to/fixtures.rst:155
msgid "One of the things that makes pytest's fixture system so powerful, is that it gives us the ability to define a generic setup step that can be reused over and over, just like a normal function would be used. Two different tests can request the same fixture and have pytest give each test their own result from that fixture."
msgstr "pytest のフィクスチャシステムを非常に強力にしている要素の一つは、通常の関数のように何度も再利用できる汎用的なセットアップステップを定義できることです。異なる2つのテストが同じフィクスチャをリクエストし、pytest がそれぞれのテストに対してそのフィクスチャから独自の結果を提供することができます。"

#: ../../how-to/fixtures.rst:161
msgid "This is extremely useful for making sure tests aren't affected by each other. We can use this system to make sure each test gets its own fresh batch of data and is starting from a clean state so it can provide consistent, repeatable results."
msgstr "これは、テストが互いに影響を受けないようにするために非常に役立ちます。このシステムを使用して、各テストが独自の新しいデータバッチを取得し、クリーンな状態から開始することを確認できるため、一貫した再現可能な結果を提供できます。"

#: ../../how-to/fixtures.rst:165
msgid "Here's an example of how this can come in handy:"
msgstr "これがどのように役立つかの例を示します："

#: ../../how-to/fixtures.rst:201
msgid "Each test here is being given its own copy of that ``list`` object, which means the ``order`` fixture is getting executed twice (the same is true for the ``first_entry`` fixture). If we were to do this by hand as well, it would look something like this:"
msgstr "ここでは、各テストにその ``list`` オブジェクトの独自のコピーが与えられています。つまり、``order`` フィクスチャが2回実行されていることを意味します（``first_entry`` フィクスチャも同様です）。これを手動で行うと次のようになります："

#: ../../how-to/fixtures.rst:241
msgid "A test/fixture can **request** more than one fixture at a time"
msgstr "テスト/フィクスチャは一度に複数のフィクスチャを **リクエスト** できます"

#: ../../how-to/fixtures.rst:243
msgid "Tests and fixtures aren't limited to **requesting** a single fixture at a time. They can request as many as they like. Here's another quick example to demonstrate:"
msgstr "テストとフィクスチャは、一度に単一のフィクスチャを **リクエスト** することに限定されません。好きなだけリクエストできます。これを示す別の簡単な例を示します："

#: ../../how-to/fixtures.rst:285
msgid "Fixtures can be **requested** more than once per test (return values are cached)"
msgstr "フィクスチャはテストごとに複数回 **リクエスト** できます（戻り値はキャッシュされます）"

#: ../../how-to/fixtures.rst:287
msgid "Fixtures can also be **requested** more than once during the same test, and pytest won't execute them again for that test. This means we can **request** fixtures in multiple fixtures that are dependent on them (and even again in the test itself) without those fixtures being executed more than once."
msgstr "フィクスチャは同じテスト中に複数回 **リクエスト** することもでき、pytest はそのテストのためにそれらを再実行しません。これにより、依存している複数のフィクスチャ（およびテスト自体でも）でフィクスチャを **リクエスト** しても、それらのフィクスチャが複数回実行されることはありません。"

#: ../../how-to/fixtures.rst:320
msgid "If a **requested** fixture was executed once for every time it was **requested** during a test, then this test would fail because both ``append_first`` and ``test_string_only`` would see ``order`` as an empty list (i.e. ``[]``), but since the return value of ``order`` was cached (along with any side effects executing it may have had) after the first time it was called, both the test and ``append_first`` were referencing the same object, and the test saw the effect ``append_first`` had on that object."
msgstr "もし **リクエスト** されたフィクスチャがテスト中にリクエストされるたびに1回実行された場合、このテストは失敗します。なぜなら、``append_first`` と ``test_string_only`` の両方が ``order`` を空のリスト（つまり ``[]``）として見るからです。しかし、``order`` の戻り値が最初に呼び出された後にキャッシュされたため（実行時に発生した副作用も含む）、テストと ``append_first`` の両方が同じオブジェクトを参照しており、テストは ``append_first`` がそのオブジェクトに与えた影響を確認しました。"

#: ../../how-to/fixtures.rst:332
msgid "Autouse fixtures (fixtures you don't have to request)"
msgstr "自動使用フィクスチャ（リクエストする必要のないフィクスチャ）"

#: ../../how-to/fixtures.rst:334
msgid "Sometimes you may want to have a fixture (or even several) that you know all your tests will depend on. \"Autouse\" fixtures are a convenient way to make all tests automatically **request** them. This can cut out a lot of redundant **requests**, and can even provide more advanced fixture usage (more on that further down)."
msgstr "すべてのテストが依存するフィクスチャ（または複数のフィクスチャ）を持ちたい場合があります。「自動使用」フィクスチャは、すべてのテストが自動的にそれらを **リクエスト** する便利な方法です。これにより、多くの冗長な **リクエスト** を省くことができ、さらに高度なフィクスチャの使用法を提供することもできます（詳細は後述します）。"

#: ../../how-to/fixtures.rst:340
msgid "We can make a fixture an autouse fixture by passing in ``autouse=True`` to the fixture's decorator. Here's a simple example for how they can be used:"
msgstr "フィクスチャのデコレータに ``autouse=True`` を渡すことで、フィクスチャを自動使用フィクスチャにすることができます。これがどのように使用できるかの簡単な例を示します："

#: ../../how-to/fixtures.rst:372
msgid "In this example, the ``append_first`` fixture is an autouse fixture. Because it happens automatically, both tests are affected by it, even though neither test **requested** it. That doesn't mean they *can't* be **requested** though; just that it isn't *necessary*."
msgstr "この例では、``append_first`` フィクスチャは自動使用フィクスチャです。自動的に発生するため、どちらのテストもそれによって影響を受けますが、どちらのテストもそれを **リクエスト** していません。それは **リクエスト** できないという意味ではなく、単に *必要ではない* ということです。"

#: ../../how-to/fixtures.rst:380
msgid "Scope: sharing fixtures across classes, modules, packages or session"
msgstr "スコープ：クラス、モジュール、パッケージ、またはセッション間でフィクスチャを共有する"

#: ../../how-to/fixtures.rst:384
msgid "Fixtures requiring network access depend on connectivity and are usually time-expensive to create.  Extending the previous example, we can add a ``scope=\"module\"`` parameter to the :py:func:`@pytest.fixture <pytest.fixture>` invocation to cause a ``smtp_connection`` fixture function, responsible to create a connection to a preexisting SMTP server, to only be invoked once per test *module* (the default is to invoke once per test *function*). Multiple test functions in a test module will thus each receive the same ``smtp_connection`` fixture instance, thus saving time. Possible values for ``scope`` are: ``function``, ``class``, ``module``, ``package`` or ``session``."
msgstr "ネットワークアクセスを必要とするフィクスチャは接続性に依存し、通常、作成に時間がかかります。前の例を拡張して、:py:func:`@pytest.fixture <pytest.fixture>` 呼び出しに ``scope=\"module\"`` パラメータを追加することで、既存の SMTP サーバーへの接続を作成する ``smtp_connection`` フィクスチャ関数がテスト *モジュール* ごとに1回だけ呼び出されるようにします（デフォルトではテスト *関数* ごとに1回呼び出されます）。テストモジュール内の複数のテスト関数は、それぞれ同じ ``smtp_connection`` フィクスチャインスタンスを受け取るため、時間を節約できます。``scope`` の可能な値は、``function``、``class``、``module``、``package``、または ``session`` です。"

#: ../../how-to/fixtures.rst:394
msgid "The next example puts the fixture function into a separate ``conftest.py`` file so that tests from multiple test modules in the directory can access the fixture function:"
msgstr "次の例では、フィクスチャ関数を別の ``conftest.py`` ファイルに配置し、ディレクトリ内の複数のテストモジュールからフィクスチャ関数にアクセスできるようにします："

#: ../../how-to/fixtures.rst:428
msgid "Here, the ``test_ehlo`` needs the ``smtp_connection`` fixture value.  pytest will discover and call the :py:func:`@pytest.fixture <pytest.fixture>` marked ``smtp_connection`` fixture function.  Running the test looks like this:"
msgstr "ここで、``test_ehlo`` は ``smtp_connection`` フィクスチャ値を必要とします。pytest は :py:func:`@pytest.fixture <pytest.fixture>` でマークされた ``smtp_connection`` フィクスチャ関数を発見して呼び出します。テストの実行は次のようになります："

#: ../../how-to/fixtures.rst:471
msgid "You see the two ``assert 0`` failing and more importantly you can also see that the **exactly same** ``smtp_connection`` object was passed into the two test functions because pytest shows the incoming argument values in the traceback.  As a result, the two test functions using ``smtp_connection`` run as quick as a single one because they reuse the same instance."
msgstr "2つの ``assert 0`` が失敗しているのがわかりますが、さらに重要なのは、pytest がトレースバックで受け取った引数の値を表示するため、2つのテスト関数に **まったく同じ** ``smtp_connection`` オブジェクトが渡されたこともわかります。その結果、``smtp_connection`` を使用する2つのテスト関数は、同じインスタンスを再利用するため、単一のテストと同じくらい速く実行されます。"

#: ../../how-to/fixtures.rst:477
msgid "If you decide that you rather want to have a session-scoped ``smtp_connection`` instance, you can simply declare it:"
msgstr "セッションスコープの ``smtp_connection`` インスタンスを持ちたい場合は、単にそれを宣言することができます："

#: ../../how-to/fixtures.rst:490
msgid "Fixture scopes"
msgstr "フィクスチャのスコープ"

#: ../../how-to/fixtures.rst:492
msgid "Fixtures are created when first requested by a test, and are destroyed based on their ``scope``:"
msgstr "フィクスチャはテストによって最初にリクエストされたときに作成され、その ``scope`` に基づいて破棄されます："

#: ../../how-to/fixtures.rst:494
msgid "``function``: the default scope, the fixture is destroyed at the end of the test."
msgstr "``function``：デフォルトのスコープで、フィクスチャはテストの終了時に破棄されます。"

#: ../../how-to/fixtures.rst:495
msgid "``class``: the fixture is destroyed during teardown of the last test in the class."
msgstr "``class``：フィクスチャはクラス内の最後のテストの後片付け中に破棄されます。"

#: ../../how-to/fixtures.rst:496
msgid "``module``: the fixture is destroyed during teardown of the last test in the module."
msgstr "``module``：フィクスチャはモジュール内の最後のテストの後片付け中に破棄されます。"

#: ../../how-to/fixtures.rst:497
msgid "``package``: the fixture is destroyed during teardown of the last test in the package where the fixture is defined, including sub-packages and sub-directories within it."
msgstr "``package``：フィクスチャは、フィクスチャが定義されているパッケージ内の最後のテストの後片付け中に破棄されます。サブパッケージおよびその中のサブディレクトリも含まれます。"

#: ../../how-to/fixtures.rst:498
msgid "``session``: the fixture is destroyed at the end of the test session."
msgstr "``session``：フィクスチャはテストセッションの終了時に破棄されます。"

#: ../../how-to/fixtures.rst:502
msgid "Pytest only caches one instance of a fixture at a time, which means that when using a parametrized fixture, pytest may invoke a fixture more than once in the given scope."
msgstr "Pytest は一度に1つのフィクスチャインスタンスしかキャッシュしないため、パラメータ化されたフィクスチャを使用する場合、pytest は指定されたスコープ内でフィクスチャを複数回呼び出すことがあります。"

#: ../../how-to/fixtures.rst:509
msgid "Dynamic scope"
msgstr "動的スコープ"

#: ../../how-to/fixtures.rst:513
msgid "In some cases, you might want to change the scope of the fixture without changing the code. To do that, pass a callable to ``scope``. The callable must return a string with a valid scope and will be executed only once - during the fixture definition. It will be called with two keyword arguments - ``fixture_name`` as a string and ``config`` with a configuration object."
msgstr "場合によっては、コードを変更せずにフィクスチャのスコープを変更したいことがあります。そのためには、``scope`` に呼び出し可能なオブジェクトを渡します。呼び出し可能なオブジェクトは有効なスコープを持つ文字列を返す必要があり、フィクスチャの定義中に1回だけ実行されます。2つのキーワード引数を使用して呼び出されます - ``fixture_name`` は文字列として、``config`` は構成オブジェクトとして。"

#: ../../how-to/fixtures.rst:518
msgid "This can be especially useful when dealing with fixtures that need time for setup, like spawning a docker container. You can use the command-line argument to control the scope of the spawned containers for different environments. See the example below."
msgstr "これは、Docker コンテナの生成など、セットアップに時間がかかるフィクスチャを扱う場合に特に役立ちます。コマンドライン引数を使用して、異なる環境の生成されたコンテナのスコープを制御できます。以下の例を参照してください。"

#: ../../how-to/fixtures.rst:539
msgid "Teardown/Cleanup (AKA Fixture finalization)"
msgstr "後片付け/クリーンアップ（別名フィクスチャの終了）"

#: ../../how-to/fixtures.rst:541
msgid "When we run our tests, we'll want to make sure they clean up after themselves so they don't mess with any other tests (and also so that we don't leave behind a mountain of test data to bloat the system). Fixtures in pytest offer a very useful teardown system, which allows us to define the specific steps necessary for each fixture to clean up after itself."
msgstr "テストを実行するとき、他のテストに影響を与えないように後片付けを行うことを確認したい（また、システムを膨らませるテストデータの山を残さないようにするため）。pytest のフィクスチャは非常に便利な後片付けシステムを提供しており、各フィクスチャが自分自身をクリーンアップするために必要な特定の手順を定義できます。"

#: ../../how-to/fixtures.rst:547
msgid "This system can be leveraged in two ways."
msgstr "このシステムは2つの方法で活用できます。"

#: ../../how-to/fixtures.rst:552
msgid "1. ``yield`` fixtures (recommended)"
msgstr "1. ``yield`` フィクスチャ（推奨）"

#: ../../how-to/fixtures.rst:556
msgid "\"Yield\" fixtures ``yield`` instead of ``return``. With these fixtures, we can run some code and pass an object back to the requesting fixture/test, just like with the other fixtures. The only differences are:"
msgstr "「Yield」フィクスチャは ``return`` の代わりに ``yield`` を使用します。これらのフィクスチャでは、いくつかのコードを実行し、他のフィクスチャと同様に、リクエストしているフィクスチャ/テストにオブジェクトを返すことができます。唯一の違いは次のとおりです："

#: ../../how-to/fixtures.rst:560
msgid "``return`` is swapped out for ``yield``."
msgstr "``return`` は ``yield`` に置き換えられます。"

#: ../../how-to/fixtures.rst:561
msgid "Any teardown code for that fixture is placed *after* the ``yield``."
msgstr "そのフィクスチャの後片付けコードは ``yield`` の *後* に配置されます。"

#: ../../how-to/fixtures.rst:563
msgid "Once pytest figures out a linear order for the fixtures, it will run each one up until it returns or yields, and then move on to the next fixture in the list to do the same thing."
msgstr "pytest がフィクスチャの線形順序を把握すると、それぞれが返されるか ``yield`` されるまで実行し、次のフィクスチャに移動して同じことを行います。"

#: ../../how-to/fixtures.rst:567
msgid "Once the test is finished, pytest will go back down the list of fixtures, but in the *reverse order*, taking each one that yielded, and running the code inside it that was *after* the ``yield`` statement."
msgstr "テストが終了すると、pytest はフィクスチャのリストを*逆順*に戻り、``yield`` された各フィクスチャを取り、その中の ``yield`` ステートメントの *後* にあるコードを実行します。"

#: ../../how-to/fixtures.rst:571
msgid "As a simple example, consider this basic email module:"
msgstr "簡単な例として、この基本的なメールモジュールを考えてみましょう："

#: ../../how-to/fixtures.rst:601
msgid "Let's say we want to test sending email from one user to another. We'll have to first make each user, then send the email from one user to the other, and finally assert that the other user received that message in their inbox. If we want to clean up after the test runs, we'll likely have to make sure the other user's mailbox is emptied before deleting that user, otherwise the system may complain."
msgstr "あるユーザーから別のユーザーにメールを送信するテストを行いたいとします。まず各ユーザーを作成し、次に1人のユーザーから別のユーザーにメールを送信し、最後に他のユーザーがそのメッセージを受信トレイで受信したことを確認する必要があります。テストの実行後にクリーンアップしたい場合は、他のユーザーを削除する前にそのユーザーのメールボックスが空であることを確認する必要があります。そうしないと、システムが不満を言うかもしれません。"

#: ../../how-to/fixtures.rst:608 ../../how-to/fixtures.rst:907
msgid "Here's what that might look like:"
msgstr "その例を示します："

#: ../../how-to/fixtures.rst:643
msgid "Because ``receiving_user`` is the last fixture to run during setup, it's the first to run during teardown."
msgstr "``receiving_user`` はセットアップ中に実行される最後のフィクスチャであるため、後片付け中に最初に実行されます。"

#: ../../how-to/fixtures.rst:646
msgid "There is a risk that even having the order right on the teardown side of things doesn't guarantee a safe cleanup. That's covered in a bit more detail in :ref:`safe teardowns`."
msgstr "後片付けの順序が正しい場合でも、安全なクリーンアップが保証されないリスクがあります。これは :ref:`safe teardowns` で詳しく説明されています。"

#: ../../how-to/fixtures.rst:657
msgid "Handling errors for yield fixture"
msgstr "yield フィクスチャのエラー処理"

#: ../../how-to/fixtures.rst:659
msgid "If a yield fixture raises an exception before yielding, pytest won't try to run the teardown code after that yield fixture's ``yield`` statement. But, for every fixture that has already run successfully for that test, pytest will still attempt to tear them down as it normally would."
msgstr "yield フィクスチャが ``yield`` する前に例外を発生させた場合、pytest はその yield フィクスチャの ``yield`` ステートメントの後に後片付けコードを実行しようとはしません。しかし、そのテストのためにすでに正常に実行されたすべてのフィクスチャについては、pytest は通常どおりにそれらを後片付けしようとします。"

#: ../../how-to/fixtures.rst:665
msgid "2. Adding finalizers directly"
msgstr "2. 直接ファイナライザを追加する"

#: ../../how-to/fixtures.rst:667
msgid "While yield fixtures are considered to be the cleaner and more straightforward option, there is another choice, and that is to add \"finalizer\" functions directly to the test's `request-context`_ object. It brings a similar result as yield fixtures, but requires a bit more verbosity."
msgstr "yield フィクスチャはよりクリーンでわかりやすいオプションと見なされますが、別の選択肢もあります。それは、テストの `request-context`_ オブジェクトに「ファイナライザ」関数を直接追加することです。yield フィクスチャと同様の結果をもたらしますが、少し冗長になります。"

#: ../../how-to/fixtures.rst:672
msgid "In order to use this approach, we have to request the `request-context`_ object (just like we would request another fixture) in the fixture we need to add teardown code for, and then pass a callable, containing that teardown code, to its ``addfinalizer`` method."
msgstr "このアプローチを使用するには、後片付けコードを追加する必要があるフィクスチャで `request-context`_ オブジェクトをリクエストし（他のフィクスチャをリクエストするのと同様に）、その後片付けコードを含む呼び出し可能なオブジェクトをその ``addfinalizer`` メソッドに渡します。"

#: ../../how-to/fixtures.rst:677
msgid "We have to be careful though, because pytest will run that finalizer once it's been added, even if that fixture raises an exception after adding the finalizer. So to make sure we don't run the finalizer code when we wouldn't need to, we would only add the finalizer once the fixture would have done something that we'd need to teardown."
msgstr "ただし注意が必要です。pytest はファイナライザが追加されると、そのフィクスチャがファイナライザを追加した後に例外を発生させた場合でも、そのファイナライザを実行します。そのため、必要のないときにファイナライザコードを実行しないようにするために、フィクスチャが後片付けする必要がある何かを行った場合にのみファイナライザを追加します。"

#: ../../how-to/fixtures.rst:683
msgid "Here's how the previous example would look using the ``addfinalizer`` method:"
msgstr "前の例を ``addfinalizer`` メソッドを使用してどのように見えるかを示します："

#: ../../how-to/fixtures.rst:732
msgid "It's a bit longer than yield fixtures and a bit more complex, but it does offer some nuances for when you're in a pinch."
msgstr "yield フィクスチャよりも少し長く、少し複雑ですが、困ったときに役立ついくつかのニュアンスを提供します。"

#: ../../how-to/fixtures.rst:742
msgid "Note on finalizer order"
msgstr "ファイナライザの順序に関する注意"

#: ../../how-to/fixtures.rst:744
msgid "Finalizers are executed in a first-in-last-out order. For yield fixtures, the first teardown code to run is from the right-most fixture, i.e. the last test parameter."
msgstr "ファイナライザは先入れ後出しの順序で実行されます。yield フィクスチャの場合、最初に実行される後片付けコードは最も右のフィクスチャ、つまり最後のテストパラメータからです。"

#: ../../how-to/fixtures.rst:785
msgid "For finalizers, the first fixture to run is last call to `request.addfinalizer`."
msgstr "ファイナライザの場合、最初に実行されるフィクスチャは `request.addfinalizer` の最後の呼び出しです。"

#: ../../how-to/fixtures.rst:819
msgid "This is so because yield fixtures use `addfinalizer` behind the scenes: when the fixture executes, `addfinalizer` registers a function that resumes the generator, which in turn calls the teardown code."
msgstr "これは、yield フィクスチャが背後で `addfinalizer` を使用するためです。フィクスチャが実行されると、`addfinalizer` はジェネレータを再開する関数を登録し、それが後片付けコードを呼び出します。"

#: ../../how-to/fixtures.rst:825
msgid "Safe teardowns"
msgstr "安全な後片付け"

#: ../../how-to/fixtures.rst:827
msgid "The fixture system of pytest is *very* powerful, but it's still being run by a computer, so it isn't able to figure out how to safely teardown everything we throw at it. If we aren't careful, an error in the wrong spot might leave stuff from our tests behind, and that can cause further issues pretty quickly."
msgstr "pytest のフィクスチャシステムは *非常に* 強力ですが、それでもコンピュータによって実行されているため、投げかけたすべてのものを安全に後片付けする方法を見つけることはできません。注意しないと、間違った場所でのエラーがテストの残骸を残し、それがさらに問題を引き起こす可能性があります。"

#: ../../how-to/fixtures.rst:832
msgid "For example, consider the following tests (based off of the mail example from above):"
msgstr "たとえば、次のテストを考えてみましょう（上記のメールの例に基づいています）："

#: ../../how-to/fixtures.rst:860
msgid "This version is a lot more compact, but it's also harder to read, doesn't have a very descriptive fixture name, and none of the fixtures can be reused easily."
msgstr "このバージョンははるかにコンパクトですが、読みづらく、非常に説明的なフィクスチャ名がなく、フィクスチャのいずれも簡単に再利用できません。"

#: ../../how-to/fixtures.rst:863
msgid "There's also a more serious issue, which is that if any of those steps in the setup raise an exception, none of the teardown code will run."
msgstr "さらに深刻な問題もあります。セットアップのいずれかのステップで例外が発生した場合、後片付けコードは実行されません。"

#: ../../how-to/fixtures.rst:866
msgid "One option might be to go with the ``addfinalizer`` method instead of yield fixtures, but that might get pretty complex and difficult to maintain (and it wouldn't be compact anymore)."
msgstr "1つのオプションは、yield フィクスチャの代わりに ``addfinalizer`` メソッドを使用することですが、それは非常に複雑で維持が難しくなる可能性があります（そしてもはやコンパクトではありません）。"

#: ../../how-to/fixtures.rst:879
msgid "Safe fixture structure"
msgstr "安全なフィクスチャ構造"

#: ../../how-to/fixtures.rst:881
msgid "The safest and simplest fixture structure requires limiting fixtures to only making one state-changing action each, and then bundling them together with their teardown code, as :ref:`the email examples above <yield fixtures>` showed."
msgstr "最も安全でシンプルなフィクスチャ構造は、各フィクスチャを1つの状態変更アクションのみに制限し、それらを後片付けコードと一緒にバンドルすることを必要とします。これは :ref:`the email examples above <yield fixtures>` で示されています。"

#: ../../how-to/fixtures.rst:885
msgid "The chance that a state-changing operation can fail but still modify state is negligible, as most of these operations tend to be `transaction <https://en.wikipedia.org/wiki/Transaction_processing>`_-based (at least at the level of testing where state could be left behind). So if we make sure that any successful state-changing action gets torn down by moving it to a separate fixture function and separating it from other, potentially failing state-changing actions, then our tests will stand the best chance at leaving the test environment the way they found it."
msgstr "状態変更操作が失敗しても状態を変更する可能性はほとんどありません。これらの操作のほとんどは `transaction <https://en.wikipedia.org/wiki/Transaction_processing>`_ ベースであるためです（少なくとも状態が残る可能性のあるテストレベルでは）。したがって、成功した状態変更アクションが別のフィクスチャ関数に移動され、他の潜在的に失敗する状態変更アクションから分離されることを確認すれば、テスト環境を見つけたままの状態で残す可能性が最も高くなります。"

#: ../../how-to/fixtures.rst:894
msgid "For an example, let's say we have a website with a login page, and we have access to an admin API where we can generate users. For our test, we want to:"
msgstr "例として、ログインページを持つウェブサイトがあり、ユーザーを生成できる管理 API にアクセスできるとします。テストのために、次のことを行いたい："

#: ../../how-to/fixtures.rst:897
msgid "Create a user through that admin API"
msgstr "その管理 API を通じてユーザーを作成する"

#: ../../how-to/fixtures.rst:898
msgid "Launch a browser using Selenium"
msgstr "Selenium を使用してブラウザを起動する"

#: ../../how-to/fixtures.rst:899
msgid "Go to the login page of our site"
msgstr "サイトのログインページに移動する"

#: ../../how-to/fixtures.rst:900
msgid "Log in as the user we created"
msgstr "作成したユーザーとしてログインする"

#: ../../how-to/fixtures.rst:901
msgid "Assert that their name is in the header of the landing page"
msgstr "ランディングページのヘッダーにその名前があることを確認する"

#: ../../how-to/fixtures.rst:903
msgid "We wouldn't want to leave that user in the system, nor would we want to leave that browser session running, so we'll want to make sure the fixtures that create those things clean up after themselves."
msgstr "そのユーザーをシステムに残したくないし、そのブラウザセッションを実行し続けたくもないので、それらを作成するフィクスチャが自分自身をクリーンアップすることを確認したい。"

#: ../../how-to/fixtures.rst:911 ../../how-to/fixtures.rst:1005
msgid "For this example, certain fixtures (i.e. ``base_url`` and ``admin_credentials``) are implied to exist elsewhere. So for now, let's assume they exist, and we're just not looking at them."
msgstr "この例では、特定のフィクスチャ（つまり ``base_url`` および ``admin_credentials``）が他の場所に存在することが示唆されています。したがって、今のところ、それらが存在すると仮定し、それらを見ていないだけです。"

#: ../../how-to/fixtures.rst:963
msgid "The way the dependencies are laid out means it's unclear if the ``user`` fixture would execute before the ``driver`` fixture. But that's ok, because those are atomic operations, and so it doesn't matter which one runs first because the sequence of events for the test is still `linearizable <https://en.wikipedia.org/wiki/Linearizability>`_. But what *does* matter is that, no matter which one runs first, if the one raises an exception while the other would not have, neither will have left anything behind. If ``driver`` executes before ``user``, and ``user`` raises an exception, the driver will still quit, and the user was never made. And if ``driver`` was the one to raise the exception, then the driver would never have been started and the user would never have been made."
msgstr "依存関係の配置方法から、``user`` フィクスチャが ``driver`` フィクスチャの前に実行されるかどうかは不明です。しかし、それは問題ありません。これらはアトミック操作であり、どちらが最初に実行されるかは関係ありません。なぜなら、テストのイベントの順序は依然として `linearizable <https://en.wikipedia.org/wiki/Linearizability>`_ だからです。しかし、*重要* なのは、どちらが最初に実行されても、片方が例外を発生させた場合、もう片方は何も残さないということです。``driver`` が ``user`` の前に実行され、``user`` が例外を発生させた場合、ドライバーは終了し、ユーザーは作成されません。そして、``driver`` が例外を発生させた場合、ドライバーは開始されず、ユーザーも作成されません。"

#: ../../how-to/fixtures.rst:985
msgid "Running multiple ``assert`` statements safely"
msgstr "複数の ``assert`` ステートメントを安全に実行する"

#: ../../how-to/fixtures.rst:987
msgid "Sometimes you may want to run multiple asserts after doing all that setup, which makes sense as, in more complex systems, a single action can kick off multiple behaviors. pytest has a convenient way of handling this and it combines a bunch of what we've gone over so far."
msgstr "すべてのセットアップを行った後に複数のアサートを実行したい場合があります。これは、より複雑なシステムでは、単一のアクションが複数の動作を引き起こす可能性があるためです。pytest にはこれを処理する便利な方法があり、これまでに説明したことの多くを組み合わせています。"

#: ../../how-to/fixtures.rst:992
msgid "All that's needed is stepping up to a larger scope, then having the **act** step defined as an autouse fixture, and finally, making sure all the fixtures are targeting that higher level scope."
msgstr "必要なのは、より大きなスコープにステップアップし、**act** ステップを自動使用フィクスチャとして定義し、最後にすべてのフィクスチャがその高レベルのスコープを対象としていることを確認することです。"

#: ../../how-to/fixtures.rst:996
msgid "Let's pull :ref:`an example from above <safe fixture structure>`, and tweak it a bit. Let's say that in addition to checking for a welcome message in the header, we also want to check for a sign out button, and a link to the user's profile."
msgstr ":ref:`an example from above <safe fixture structure>` を引き出し、少し調整しましょう。ヘッダーにウェルカムメッセージがあるかどうかを確認するだけでなく、サインアウトボタンとユーザープロファイルへのリンクも確認したいとします。"

#: ../../how-to/fixtures.rst:1000
msgid "Let's take a look at how we can structure that so we can run multiple asserts without having to repeat all those steps again."
msgstr "すべてのステップを再度繰り返すことなく、複数のアサートを実行できるように、それをどのように構築できるかを見てみましょう。"

#: ../../how-to/fixtures.rst:1065
msgid "Notice that the methods are only referencing ``self`` in the signature as a formality. No state is tied to the actual test class as it might be in the ``unittest.TestCase`` framework. Everything is managed by the pytest fixture system."
msgstr "メソッドが署名で ``self`` を形式的に参照しているだけであることに注意してください。状態は ``unittest.TestCase`` フレームワークのように実際のテストクラスに結び付けられていません。すべては pytest フィクスチャシステムによって管理されています。"

#: ../../how-to/fixtures.rst:1070
msgid "Each method only has to request the fixtures that it actually needs without worrying about order. This is because the **act** fixture is an autouse fixture, and it made sure all the other fixtures executed before it. There's no more changes of state that need to take place, so the tests are free to make as many non-state-changing queries as they want without risking stepping on the toes of the other tests."
msgstr "各メソッドは、順序を気にせずに実際に必要なフィクスチャをリクエストするだけで済みます。これは、**act** フィクスチャが自動使用フィクスチャであり、他のすべてのフィクスチャがその前に実行されることを確認したためです。状態の変更はもう必要ないため、テストは他のテストの邪魔をするリスクなしに、好きなだけ状態を変更しないクエリを自由に行うことができます。"

#: ../../how-to/fixtures.rst:1077
msgid "The ``login`` fixture is defined inside the class as well, because not every one of the other tests in the module will be expecting a successful login, and the **act** may need to be handled a little differently for another test class. For example, if we wanted to write another test scenario around submitting bad credentials, we could handle it by adding something like this to the test file:"
msgstr "``login`` フィクスチャもクラス内で定義されています。モジュール内の他のすべてのテストが成功したログインを期待しているわけではなく、**act** は別のテストクラスに対して少し異なる方法で処理する必要がある場合があります。たとえば、不正な資格情報を送信する別のテストシナリオを作成したい場合は、次のようなものをテストファイルに追加して処理できます："

#: ../../how-to/fixtures.rst:1106
msgid "Fixtures can introspect the requesting test context"
msgstr "フィクスチャはリクエストしているテストコンテキストを内省できます"

#: ../../how-to/fixtures.rst:1108
msgid "Fixture functions can accept the :py:class:`request <_pytest.fixtures.FixtureRequest>` object to introspect the \"requesting\" test function, class or module context. Further extending the previous ``smtp_connection`` fixture example, let's read an optional server URL from the test module which uses our fixture:"
msgstr "フィクスチャ関数は :py:class:`request <_pytest.fixtures.FixtureRequest>` オブジェクトを受け入れて、「リクエストしている」テスト関数、クラス、またはモジュールコンテキストを内省できます。前の ``smtp_connection`` フィクスチャの例をさらに拡張して、フィクスチャを使用するテストモジュールからオプションのサーバー URL を読み取ります："

#: ../../how-to/fixtures.rst:1129
msgid "We use the ``request.module`` attribute to optionally obtain an ``smtpserver`` attribute from the test module.  If we just execute again, nothing much has changed:"
msgstr "``request.module`` 属性を使用して、テストモジュールからオプションで ``smtpserver`` 属性を取得します。再度実行するだけで、ほとんど何も変わりません："

#: ../../how-to/fixtures.rst:1143
msgid "Let's quickly create another test module that actually sets the server URL in its module namespace:"
msgstr "モジュールの名前空間にサーバー URL を実際に設定する別のテストモジュールをすばやく作成しましょう："

#: ../../how-to/fixtures.rst:1156
msgid "Running it:"
msgstr "実行中："

#: ../../how-to/fixtures.rst:1173
msgid "voila! The ``smtp_connection`` fixture function picked up our mail server name from the module namespace."
msgstr "ほら！ ``smtp_connection`` フィクスチャ関数がモジュールの名前空間からメールサーバー名を取得しました。"

#: ../../how-to/fixtures.rst:1179
msgid "Using markers to pass data to fixtures"
msgstr "マーカーを使用してデータをフィクスチャに渡す"

#: ../../how-to/fixtures.rst:1181
msgid "Using the :py:class:`request <_pytest.fixtures.FixtureRequest>` object, a fixture can also access markers which are applied to a test function. This can be useful to pass data into a fixture from a test:"
msgstr ":py:class:`request <_pytest.fixtures.FixtureRequest>` オブジェクトを使用して、フィクスチャはテスト関数に適用されるマーカーにもアクセスできます。これは、テストからフィクスチャにデータを渡すのに役立ちます："

#: ../../how-to/fixtures.rst:1210
msgid "Factories as fixtures"
msgstr "フィクスチャとしてのファクトリ"

#: ../../how-to/fixtures.rst:1212
msgid "The \"factory as fixture\" pattern can help in situations where the result of a fixture is needed multiple times in a single test. Instead of returning data directly, the fixture instead returns a function which generates the data. This function can then be called multiple times in the test."
msgstr "「フィクスチャとしてのファクトリ」パターンは、フィクスチャの結果が単一のテストで複数回必要な状況で役立ちます。データを直接返すのではなく、フィクスチャはデータを生成する関数を返します。この関数はテストで複数回呼び出すことができます。"

#: ../../how-to/fixtures.rst:1217
msgid "Factories can have parameters as needed:"
msgstr "ファクトリには必要に応じてパラメータを指定できます："

#: ../../how-to/fixtures.rst:1234
msgid "If the data created by the factory requires managing, the fixture can take care of that:"
msgstr "ファクトリによって作成されたデータの管理が必要な場合、フィクスチャがそれを処理できます："

#: ../../how-to/fixtures.rst:1262
msgid "Parametrizing fixtures"
msgstr "フィクスチャのパラメータ化"

#: ../../how-to/fixtures.rst:1264
msgid "Fixture functions can be parametrized in which case they will be called multiple times, each time executing the set of dependent tests, i.e. the tests that depend on this fixture.  Test functions usually do not need to be aware of their re-running.  Fixture parametrization helps to write exhaustive functional tests for components which themselves can be configured in multiple ways."
msgstr "フィクスチャ関数はパラメータ化でき、その場合、複数回呼び出され、各回に依存するテストセット、つまりこのフィクスチャに依存するテストを実行します。テスト関数は通常、再実行を意識する必要はありません。フィクスチャのパラメータ化は、複数の方法で構成できるコンポーネントの包括的な機能テストを作成するのに役立ちます。"

#: ../../how-to/fixtures.rst:1271
msgid "Extending the previous example, we can flag the fixture to create two ``smtp_connection`` fixture instances which will cause all tests using the fixture to run twice.  The fixture function gets access to each parameter through the special :py:class:`request <pytest.FixtureRequest>` object:"
msgstr "前の例を拡張して、フィクスチャに2つの ``smtp_connection`` フィクスチャインスタンスを作成するフラグを立てることができ、これによりフィクスチャを使用するすべてのテストが2回実行されます。フィクスチャ関数は、特別な :py:class:`request <pytest.FixtureRequest>` オブジェクトを介して各パラメータにアクセスします："

#: ../../how-to/fixtures.rst:1291
msgid "The main change is the declaration of ``params`` with :py:func:`@pytest.fixture <pytest.fixture>`, a list of values for each of which the fixture function will execute and can access a value via ``request.param``.  No test function code needs to change. So let's just do another run:"
msgstr "主な変更点は、:py:func:`@pytest.fixture <pytest.fixture>` で ``params`` を宣言することで、フィクスチャ関数が実行される値のリストを作成し、``request.param`` を介して値にアクセスできるようにすることです。テスト関数のコードを変更する必要はありません。では、もう一度実行してみましょう："

#: ../../how-to/fixtures.rst:1358
msgid "We see that our two test functions each ran twice, against the different ``smtp_connection`` instances.  Note also, that with the ``mail.python.org`` connection the second test fails in ``test_ehlo`` because a different server string is expected than what arrived."
msgstr "2つのテスト関数がそれぞれ異なる ``smtp_connection`` インスタンスに対して2回実行されたことがわかります。また、``mail.python.org`` 接続では、2番目のテストが ``test_ehlo`` で失敗します。到着したサーバー文字列とは異なる文字列が予期されるためです。"

#: ../../how-to/fixtures.rst:1363
msgid "pytest will build a string that is the test ID for each fixture value in a parametrized fixture, e.g. ``test_ehlo[smtp.gmail.com]`` and ``test_ehlo[mail.python.org]`` in the above examples.  These IDs can be used with ``-k`` to select specific cases to run, and they will also identify the specific case when one is failing.  Running pytest with ``--collect-only`` will show the generated IDs."
msgstr "pytest は、パラメータ化されたフィクスチャ内の各フィクスチャ値のテスト ID となる文字列を構築します。たとえば、上記の例では ``test_ehlo[smtp.gmail.com]`` および ``test_ehlo[mail.python.org]`` です。これらの ID は ``-k`` と一緒に使用して実行する特定のケースを選択でき、1つが失敗した場合に特定のケースを識別します。``--collect-only`` オプションで pytest を実行すると、生成された ID が表示されます。"

#: ../../how-to/fixtures.rst:1370
msgid "Numbers, strings, booleans and ``None`` will have their usual string representation used in the test ID. For other objects, pytest will make a string based on the argument name.  It is possible to customise the string used in a test ID for a certain fixture value by using the ``ids`` keyword argument:"
msgstr "数値、文字列、ブール値、および ``None`` は、テスト ID で通常の文字列表現が使用されます。他のオブジェクトの場合、pytest は引数名に基づいて文字列を作成します。特定のフィクスチャ値のテスト ID で使用される文字列を ``ids`` キーワード引数を使用してカスタマイズすることができます："

#: ../../how-to/fixtures.rst:1406
msgid "The above shows how ``ids`` can be either a list of strings to use or a function which will be called with the fixture value and then has to return a string to use.  In the latter case if the function returns ``None`` then pytest's auto-generated ID will be used."
msgstr "上記は、``ids`` が使用する文字列のリストであるか、フィクスチャ値で呼び出され、使用する文字列を返す必要がある関数であるかのいずれかであることを示しています。後者の場合、関数が ``None`` を返すと、pytest の自動生成された ID が使用されます。"

#: ../../how-to/fixtures.rst:1411
msgid "Running the above tests results in the following test IDs being used:"
msgstr "上記のテストを実行すると、次のテスト ID が使用されます："

#: ../../how-to/fixtures.rst:1445
msgid "Using marks with parametrized fixtures"
msgstr "パラメータ化されたフィクスチャでマークを使用する"

#: ../../how-to/fixtures.rst:1447
msgid ":func:`pytest.param` can be used to apply marks in values sets of parametrized fixtures in the same way that they can be used with :ref:`@pytest.mark.parametrize <@pytest.mark.parametrize>`."
msgstr ":func:`pytest.param` は、:ref:`@pytest.mark.parametrize <@pytest.mark.parametrize>` と同じ方法で、パラメータ化されたフィクスチャの値セットにマークを適用するために使用できます。"

#: ../../how-to/fixtures.rst:1450
msgid "Example:"
msgstr "例："

#: ../../how-to/fixtures.rst:1466
msgid "Running this test will *skip* the invocation of ``data_set`` with value ``2``:"
msgstr "このテストを実行すると、値 ``2`` で ``data_set`` の呼び出しが *スキップ* されます："

#: ../../how-to/fixtures.rst:1486
msgid "Modularity: using fixtures from a fixture function"
msgstr "モジュール性：フィクスチャ関数からフィクスチャを使用する"

#: ../../how-to/fixtures.rst:1488
msgid "In addition to using fixtures in test functions, fixture functions can use other fixtures themselves.  This contributes to a modular design of your fixtures and allows reuse of framework-specific fixtures across many projects.  As a simple example, we can extend the previous example and instantiate an object ``app`` where we stick the already defined ``smtp_connection`` resource into it:"
msgstr "テスト関数でフィクスチャを使用することに加えて、フィクスチャ関数自体が他のフィクスチャを使用することもできます。これにより、フィクスチャのモジュール設計に貢献し、フレームワーク固有のフィクスチャを多くのプロジェクトで再利用できるようになります。簡単な例として、前の例を拡張して、すでに定義されている ``smtp_connection`` リソースを挿入するオブジェクト ``app`` をインスタンス化できます："

#: ../../how-to/fixtures.rst:1515
msgid "Here we declare an ``app`` fixture which receives the previously defined ``smtp_connection`` fixture and instantiates an ``App`` object with it.  Let's run it:"
msgstr "ここでは、以前に定義された ``smtp_connection`` フィクスチャを受け取り、それを使用して ``App`` オブジェクトをインスタンス化する ``app`` フィクスチャを宣言します。実行してみましょう："

#: ../../how-to/fixtures.rst:1532
msgid "Due to the parametrization of ``smtp_connection``, the test will run twice with two different ``App`` instances and respective smtp servers.  There is no need for the ``app`` fixture to be aware of the ``smtp_connection`` parametrization because pytest will fully analyse the fixture dependency graph."
msgstr "``smtp_connection`` のパラメータ化により、テストは2つの異なる ``App`` インスタンスとそれぞれの smtp サーバーで2回実行されます。pytest はフィクスチャの依存関係グラフを完全に分析するため、``app`` フィクスチャが ``smtp_connection`` のパラメータ化を認識する必要はありません。"

#: ../../how-to/fixtures.rst:1537
msgid "Note that the ``app`` fixture has a scope of ``module`` and uses a module-scoped ``smtp_connection`` fixture.  The example would still work if ``smtp_connection`` was cached on a ``session`` scope: it is fine for fixtures to use \"broader\" scoped fixtures but not the other way round: A session-scoped fixture could not use a module-scoped one in a meaningful way."
msgstr "``app`` フィクスチャは ``module`` のスコープを持ち、モジュールスコープの ``smtp_connection`` フィクスチャを使用することに注意してください。``smtp_connection`` が ``session`` スコープでキャッシュされている場合でも、例は機能します。フィクスチャが「より広い」スコープのフィクスチャを使用することは問題ありませんが、その逆は意味がありません。セッションスコープのフィクスチャは、モジュールスコープのフィクスチャを意味のある方法で使用することはできません。"

#: ../../how-to/fixtures.rst:1548
msgid "Automatic grouping of tests by fixture instances"
msgstr "フィクスチャインスタンスによるテストの自動グループ化"

#: ../../how-to/fixtures.rst:1552
msgid "pytest minimizes the number of active fixtures during test runs. If you have a parametrized fixture, then all the tests using it will first execute with one instance and then finalizers are called before the next fixture instance is created.  Among other things, this eases testing of applications which create and use global state."
msgstr "pytest はテスト実行中のアクティブなフィクスチャの数を最小限に抑えます。パラメータ化されたフィクスチャがある場合、それを使用するすべてのテストは最初に1つのインスタンスで実行され、次のフィクスチャインスタンスが作成される前にファイナライザが呼び出されます。これにより、グローバル状態を作成および使用するアプリケーションのテストが容易になります。"

#: ../../how-to/fixtures.rst:1558
msgid "The following example uses two parametrized fixtures, one of which is scoped on a per-module basis, and all the functions perform ``print`` calls to show the setup/teardown flow:"
msgstr "次の例では、2つのパラメータ化されたフィクスチャを使用します。そのうちの1つはモジュールごとにスコープされており、すべての関数が ``print`` 呼び出しを実行してセットアップ/後片付けのフローを示します："

#: ../../how-to/fixtures.rst:1596
msgid "Let's run the tests in verbose mode and with looking at the print-output:"
msgstr "テストを詳細モードで実行し、print 出力を確認しましょう："

#: ../../how-to/fixtures.rst:1642
msgid "You can see that the parametrized module-scoped ``modarg`` resource caused an ordering of test execution that lead to the fewest possible \"active\" resources. The finalizer for the ``mod1`` parametrized resource was executed before the ``mod2`` resource was setup."
msgstr "パラメータ化されたモジュールスコープの ``modarg`` リソースが、可能な限り少ない「アクティブ」リソースをもたらすテスト実行の順序を引き起こしたことがわかります。``mod1`` パラメータ化リソースのファイナライザは、``mod2`` リソースがセットアップされる前に実行されました。"

#: ../../how-to/fixtures.rst:1647
msgid "In particular notice that test_0 is completely independent and finishes first. Then test_1 is executed with ``mod1``, then test_2 with ``mod1``, then test_1 with ``mod2`` and finally test_2 with ``mod2``."
msgstr "特に、test_0 が完全に独立しており、最初に終了することに注意してください。次に、test_1 が ``mod1`` で実行され、次に test_2 が ``mod1`` で実行され、次に test_1 が ``mod2`` で実行され、最後に test_2 が ``mod2`` で実行されます。"

#: ../../how-to/fixtures.rst:1651
msgid "The ``otherarg`` parametrized resource (having function scope) was set up before and teared down after every test that used it."
msgstr "``otherarg`` パラメータ化リソース（関数スコープを持つ）は、使用するすべてのテストの前にセットアップされ、後に後片付けされました。"

#: ../../how-to/fixtures.rst:1658
msgid "Use fixtures in classes and modules with ``usefixtures``"
msgstr "クラスおよびモジュールで ``usefixtures`` を使用してフィクスチャを使用する"

#: ../../how-to/fixtures.rst:1662
msgid "Sometimes test functions do not directly need access to a fixture object. For example, tests may require to operate with an empty directory as the current working directory but otherwise do not care for the concrete directory.  Here is how you can use the standard :mod:`tempfile` and pytest fixtures to achieve it.  We separate the creation of the fixture into a :file:`conftest.py` file:"
msgstr "テスト関数がフィクスチャオブジェクトに直接アクセスする必要がない場合があります。たとえば、テストでは空のディレクトリを現在の作業ディレクトリとして操作する必要がありますが、具体的なディレクトリには関心がありません。標準の :mod:`tempfile` および pytest フィクスチャを使用してこれを実現する方法は次のとおりです。フィクスチャの作成を :file:`conftest.py` ファイルに分離します："

#: ../../how-to/fixtures.rst:1688
msgid "and declare its use in a test module via a ``usefixtures`` marker:"
msgstr "そして、``usefixtures`` マーカーを介してテストモジュールでその使用を宣言します："

#: ../../how-to/fixtures.rst:1708
msgid "Due to the ``usefixtures`` marker, the ``cleandir`` fixture will be required for the execution of each test method, just as if you specified a \"cleandir\" function argument to each of them.  Let's run it to verify our fixture is activated and the tests pass:"
msgstr "``usefixtures`` マーカーのため、各テストメソッドの実行には ``cleandir`` フィクスチャが必要になります。これは、各テストメソッドに「cleandir」関数引数を指定した場合と同じです。フィクスチャがアクティブ化され、テストが合格することを確認するために実行してみましょう："

#: ../../how-to/fixtures.rst:1719
msgid "You can specify multiple fixtures like this:"
msgstr "このように複数のフィクスチャを指定できます："

#: ../../how-to/fixtures.rst:1726
msgid "and you may specify fixture usage at the test module level using :globalvar:`pytestmark`:"
msgstr "そして、:globalvar:`pytestmark` を使用してテストモジュールレベルでフィクスチャの使用を指定できます："

#: ../../how-to/fixtures.rst:1733
msgid "It is also possible to put fixtures required by all tests in your project into an ini-file:"
msgstr "プロジェクト内のすべてのテストに必要なフィクスチャを ini ファイルに入れることも可能です："

#: ../../how-to/fixtures.rst:1745
msgid "Note this mark has no effect in **fixture functions**. For example, this **will not work as expected**:"
msgstr "このマークは **フィクスチャ関数** には影響しません。たとえば、これは **期待どおりに機能しません**："

#: ../../how-to/fixtures.rst:1754
msgid "This generates a deprecation warning, and will become an error in Pytest 8."
msgstr "これにより非推奨警告が生成され、Pytest 8 ではエラーになります。"

#: ../../how-to/fixtures.rst:1759
msgid "Overriding fixtures on various levels"
msgstr "さまざまなレベルでフィクスチャをオーバーライドする"

#: ../../how-to/fixtures.rst:1761
msgid "In relatively large test suite, you most likely need to ``override`` a ``global`` or ``root`` fixture with a ``locally`` defined one, keeping the test code readable and maintainable."
msgstr "比較的大規模なテストスイートでは、テストコードを読みやすく保守しやすくするために、``global`` または ``root`` フィクスチャを ``locally`` 定義されたものに ``override`` する必要がある可能性が高いです。"

#: ../../how-to/fixtures.rst:1765
msgid "Override a fixture on a folder (conftest) level"
msgstr "フォルダ（conftest）レベルでフィクスチャをオーバーライドする"

#: ../../how-to/fixtures.rst:1767 ../../how-to/fixtures.rst:1806
#: ../../how-to/fixtures.rst:1847 ../../how-to/fixtures.rst:1883
msgid "Given the tests file structure is:"
msgstr "テストファイルの構造が次のようになっているとします："

#: ../../how-to/fixtures.rst:1799
msgid "As you can see, a fixture with the same name can be overridden for certain test folder level. Note that the ``base`` or ``super`` fixture can be accessed from the ``overriding`` fixture easily - used in the example above."
msgstr "ご覧のとおり、同じ名前のフィクスチャは特定のテストフォルダレベルでオーバーライドできます。``base`` または ``super`` フィクスチャには ``overriding`` フィクスチャから簡単にアクセスできます - 上記の例で使用されています。"

#: ../../how-to/fixtures.rst:1804
msgid "Override a fixture on a test module level"
msgstr "テストモジュールレベルでフィクスチャをオーバーライドする"

#: ../../how-to/fixtures.rst:1841
msgid "In the example above, a fixture with the same name can be overridden for certain test module."
msgstr "上記の例では、同じ名前のフィクスチャは特定のテストモジュールでオーバーライドできます。"

#: ../../how-to/fixtures.rst:1845
msgid "Override a fixture with direct test parametrization"
msgstr "直接テストパラメータ化でフィクスチャをオーバーライドする"

#: ../../how-to/fixtures.rst:1876
msgid "In the example above, a fixture value is overridden by the test parameter value. Note that the value of the fixture can be overridden this way even if the test doesn't use it directly (doesn't mention it in the function prototype)."
msgstr "上記の例では、フィクスチャ値がテストパラメータ値によってオーバーライドされます。テストがそれを直接使用しない場合でも（関数プロトタイプで言及していない場合でも）、フィクスチャの値はこの方法でオーバーライドできることに注意してください。"

#: ../../how-to/fixtures.rst:1881
msgid "Override a parametrized fixture with non-parametrized one and vice versa"
msgstr "パラメータ化されたフィクスチャを非パラメータ化されたフィクスチャでオーバーライドし、その逆も可能"

#: ../../how-to/fixtures.rst:1926
msgid "In the example above, a parametrized fixture is overridden with a non-parametrized version, and a non-parametrized fixture is overridden with a parametrized version for certain test module. The same applies for the test folder level obviously."
msgstr "上記の例では、パラメータ化されたフィクスチャが非パラメータ化されたバージョンでオーバーライドされ、非パラメータ化されたフィクスチャが特定のテストモジュールのパラメータ化されたバージョンでオーバーライドされます。同じことがテストフォルダレベルにも適用されます。"

#: ../../how-to/fixtures.rst:1932
msgid "Using fixtures from other projects"
msgstr "他のプロジェクトからフィクスチャを使用する"

#: ../../how-to/fixtures.rst:1934
msgid "Usually projects that provide pytest support will use :ref:`entry points <pip-installable plugins>`, so just installing those projects into an environment will make those fixtures available for use."
msgstr "通常、pytest サポートを提供するプロジェクトは :ref:`entry points <pip-installable plugins>` を使用するため、それらのプロジェクトを環境にインストールするだけで、それらのフィクスチャが使用可能になります。"

#: ../../how-to/fixtures.rst:1937
msgid "In case you want to use fixtures from a project that does not use entry points, you can define :globalvar:`pytest_plugins` in your top ``conftest.py`` file to register that module as a plugin."
msgstr "エントリーポイントを使用しないプロジェクトからフィクスチャを使用したい場合は、トップ ``conftest.py`` ファイルに :globalvar:`pytest_plugins` を定義して、そのモジュールをプラグインとして登録できます。"

#: ../../how-to/fixtures.rst:1941
msgid "Suppose you have some fixtures in ``mylibrary.fixtures`` and you want to reuse them into your ``app/tests`` directory."
msgstr "``mylibrary.fixtures`` にいくつかのフィクスチャがあり、それらを ``app/tests`` ディレクトリで再利用したいとします。"

#: ../../how-to/fixtures.rst:1944
msgid "All you need to do is to define :globalvar:`pytest_plugins` in ``app/tests/conftest.py`` pointing to that module."
msgstr "必要なのは、``app/tests/conftest.py`` に :globalvar:`pytest_plugins` を定義して、そのモジュールを指すことだけです。"

#: ../../how-to/fixtures.rst:1951
msgid "This effectively registers ``mylibrary.fixtures`` as a plugin, making all its fixtures and hooks available to tests in ``app/tests``."
msgstr "これにより、``mylibrary.fixtures`` がプラグインとして効果的に登録され、そのすべてのフィクスチャとフックが ``app/tests`` のテストで使用可能になります。"

#: ../../how-to/fixtures.rst:1956
msgid "Sometimes users will *import* fixtures from other projects for use, however this is not recommended: importing fixtures into a module will register them in pytest as *defined* in that module."
msgstr "ユーザーが他のプロジェクトからフィクスチャを *インポート* して使用することがありますが、これは推奨されません。フィクスチャをモジュールにインポートすると、そのモジュールで *定義* されたものとして pytest に登録されます。"

#: ../../how-to/fixtures.rst:1960
msgid "This has minor consequences, such as appearing multiple times in ``pytest --help``, but it is not **recommended** because this behavior might change/stop working in future versions."
msgstr "これには、``pytest --help`` に複数回表示されるなどの小さな影響がありますが、この動作は将来のバージョンで変更/動作しなくなる可能性があるため、**推奨されません**。"

