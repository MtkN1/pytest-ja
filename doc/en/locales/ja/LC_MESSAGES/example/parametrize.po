# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2015, holger krekel and pytest-dev team
# This file is distributed under the same license as the pytest package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2025.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: pytest 0.1.dev16209\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2025-02-05 00:52+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language: ja\n"
"Language-Team: ja <LL@li.org>\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.17.0\n"

#: ../../example/parametrize.rst:5
msgid "Parametrizing tests"
msgstr "テストのパラメータ化"

#: ../../example/parametrize.rst:7
msgid "``pytest`` allows to easily parametrize test functions. For basic docs, see :ref:`parametrize-basics`."
msgstr "``pytest`` を使用すると、テスト関数を簡単にパラメータ化できます。基本的なドキュメントについては、:ref:`parametrize-basics` を参照してください。"

#: ../../example/parametrize.rst:10
msgid "In the following we provide some examples using the builtin mechanisms."
msgstr "以下では、組み込みのメカニズムを使用したいくつかの例を示します。"

#: ../../example/parametrize.rst:14
msgid "Generating parameters combinations, depending on command line"
msgstr "コマンドラインに応じたパラメータの組み合わせの生成"

#: ../../example/parametrize.rst:18
msgid "Let's say we want to execute a test with different computation parameters and the parameter range shall be determined by a command line argument.  Let's first write a simple (do-nothing) computation test:"
msgstr "異なる計算パラメータでテストを実行し、パラメータ範囲をコマンドライン引数で決定したいとします。まず、簡単な (何もしない) 計算テストを書いてみましょう："

#: ../../example/parametrize.rst:30
msgid "Now we add a test configuration like this:"
msgstr "次に、このようなテスト構成を追加します："

#: ../../example/parametrize.rst:49
msgid "This means that we only run 2 tests if we do not pass ``--all``:"
msgstr "これは、``--all`` を渡さない場合、2つのテストのみを実行することを意味します："

#: ../../example/parametrize.rst:57
msgid "We run only two computations, so we see two dots. let's run the full monty:"
msgstr "計算を2回だけ実行するので、2つのドットが表示されます。完全な範囲を実行してみましょう："

#: ../../example/parametrize.rst:78
msgid "As expected when running the full range of ``param1`` values we'll get an error on the last one."
msgstr "予想通り、``param1`` の全範囲を実行すると、最後の値でエラーが発生します。"

#: ../../example/parametrize.rst:83
msgid "Different options for test IDs"
msgstr "テストIDの異なるオプション"

#: ../../example/parametrize.rst:85
msgid "pytest will build a string that is the test ID for each set of values in a parametrized test. These IDs can be used with ``-k`` to select specific cases to run, and they will also identify the specific case when one is failing. Running pytest with ``--collect-only`` will show the generated IDs."
msgstr "pytestは、パラメータ化されたテストの各値セットに対してテストIDとなる文字列を構築します。これらのIDは、``-k`` を使用して特定のケースを選択して実行するために使用でき、失敗した場合には特定のケースを識別します。``--collect-only`` オプションでpytestを実行すると、生成されたIDが表示されます。"

#: ../../example/parametrize.rst:90
msgid "Numbers, strings, booleans and None will have their usual string representation used in the test ID. For other objects, pytest will make a string based on the argument name:"
msgstr "数値、文字列、ブール値、およびNoneは、通常の文字列表現がテストIDに使用されます。他のオブジェクトの場合、pytestは引数名に基づいて文字列を作成します："

#: ../../example/parametrize.rst:147
msgid "In ``test_timedistance_v0``, we let pytest generate the test IDs."
msgstr "``test_timedistance_v0`` では、pytestにテストIDを生成させます。"

#: ../../example/parametrize.rst:149
msgid "In ``test_timedistance_v1``, we specified ``ids`` as a list of strings which were used as the test IDs. These are succinct, but can be a pain to maintain."
msgstr "``test_timedistance_v1`` では、テストIDとして使用される文字列のリストとして ``ids`` を指定しました。これらは簡潔ですが、維持するのが大変です。"

#: ../../example/parametrize.rst:152
msgid "In ``test_timedistance_v2``, we specified ``ids`` as a function that can generate a string representation to make part of the test ID. So our ``datetime`` values use the label generated by ``idfn``, but because we didn't generate a label for ``timedelta`` objects, they are still using the default pytest representation:"
msgstr "``test_timedistance_v2`` では、テストIDの一部を生成する文字列表現を生成できる関数として ``ids`` を指定しました。したがって、``datetime`` 値は ``idfn`` によって生成されたラベルを使用しますが、``timedelta`` オブジェクトのラベルを生成しなかったため、デフォルトのpytest表現を使用しています："

#: ../../example/parametrize.rst:178
msgid "In ``test_timedistance_v3``, we used ``pytest.param`` to specify the test IDs together with the actual data, instead of listing them separately."
msgstr "``test_timedistance_v3`` では、テストIDを実際のデータと一緒に指定するために ``pytest.param`` を使用し、別々にリストするのではなく一緒に指定しました。"

#: ../../example/parametrize.rst:182
msgid "A quick port of \"testscenarios\""
msgstr "\"testscenarios\" の簡単な移植"

#: ../../example/parametrize.rst:184
msgid "Here is a quick port to run tests configured with :pypi:`testscenarios`, an add-on from Robert Collins for the standard unittest framework. We only have to work a bit to construct the correct arguments for pytest's :py:func:`Metafunc.parametrize <pytest.Metafunc.parametrize>`:"
msgstr "ここでは、標準のunittestフレームワーク用のRobert Collinsのアドオンである :pypi:`testscenarios` で構成されたテストを実行するための簡単な移植を示します。pytestの :py:func:`Metafunc.parametrize <pytest.Metafunc.parametrize>` の正しい引数を構築するために少し作業するだけです："

#: ../../example/parametrize.rst:218
msgid "this is a fully self-contained example which you can run with:"
msgstr "これは、次のコマンドで実行できる完全に自己完結型の例です："

#: ../../example/parametrize.rst:232
msgid "If you just collect tests you'll also nicely see 'advanced' and 'basic' as variants for the test function:"
msgstr "テストを収集するだけでも、テスト関数のバリエーションとして 'advanced' と 'basic' がきれいに表示されます："

#: ../../example/parametrize.rst:252
msgid "Note that we told ``metafunc.parametrize()`` that your scenario values should be considered class-scoped.  With pytest-2.3 this leads to a resource-based ordering."
msgstr "``metafunc.parametrize()`` に対して、シナリオ値はクラススコープとして考慮すべきであると伝えました。pytest-2.3では、これによりリソースベースの順序付けが行われます。"

#: ../../example/parametrize.rst:257
msgid "Deferring the setup of parametrized resources"
msgstr "パラメータ化されたリソースのセットアップの延期"

#: ../../example/parametrize.rst:261
msgid "The parametrization of test functions happens at collection time.  It is a good idea to setup expensive resources like DB connections or subprocess only when the actual test is run. Here is a simple example how you can achieve that. This test requires a ``db`` object fixture:"
msgstr "テスト関数のパラメータ化は収集時に行われます。実際のテストが実行されるときにのみ、DB接続やサブプロセスなどの高価なリソースをセットアップするのが良い考えです。これを達成する方法の簡単な例を示します。このテストには ``db`` オブジェクトフィクスチャが必要です："

#: ../../example/parametrize.rst:279
msgid "We can now add a test configuration that generates two invocations of the ``test_db_initialized`` function and also implements a factory that creates a database object for the actual test invocations:"
msgstr "これで、``test_db_initialized`` 関数の2つの呼び出しを生成するテスト構成を追加し、実際のテスト呼び出しのためにデータベースオブジェクトを作成するファクトリを実装できます："

#: ../../example/parametrize.rst:311
msgid "Let's first see how it looks like at collection time:"
msgstr "まず、収集時にどのように見えるかを見てみましょう："

#: ../../example/parametrize.rst:328
msgid "And then when we run the test:"
msgstr "次に、テストを実行すると："

#: ../../example/parametrize.rst:350
msgid "The first invocation with ``db == \"DB1\"`` passed while the second with ``db == \"DB2\"`` failed.  Our ``db`` fixture function has instantiated each of the DB values during the setup phase while the ``pytest_generate_tests`` generated two according calls to the ``test_db_initialized`` during the collection phase."
msgstr "``db == \"DB1\"`` の最初の呼び出しは成功し、``db == \"DB2\"`` の2回目の呼び出しは失敗しました。私たちの ``db`` フィクスチャ関数は、セットアップフェーズ中に各DB値をインスタンス化し、``pytest_generate_tests`` は収集フェーズ中に ``test_db_initialized`` への2つの呼び出しを生成しました。"

#: ../../example/parametrize.rst:353
msgid "Indirect parametrization"
msgstr "間接パラメータ化"

#: ../../example/parametrize.rst:355
msgid "Using the ``indirect=True`` parameter when parametrizing a test allows to parametrize a test with a fixture receiving the values before passing them to a test:"
msgstr "テストをパラメータ化する際に ``indirect=True`` パラメータを使用すると、値を受け取るフィクスチャを使用してテストをパラメータ化し、それをテストに渡す前に行うことができます："

#: ../../example/parametrize.rst:373
msgid "This can be used, for example, to do more expensive setup at test run time in the fixture, rather than having to run those setup steps at collection time."
msgstr "これは、たとえば、収集時にセットアップ手順を実行するのではなく、フィクスチャ内でテスト実行時により高価なセットアップを行うために使用できます。"

#: ../../example/parametrize.rst:379
msgid "Apply indirect on particular arguments"
msgstr "特定の引数に間接を適用する"

#: ../../example/parametrize.rst:381
msgid "Very often parametrization uses more than one argument name. There is opportunity to apply ``indirect`` parameter on particular arguments. It can be done by passing list or tuple of arguments' names to ``indirect``. In the example below there is a function ``test_indirect`` which uses two fixtures: ``x`` and ``y``. Here we give to indirect the list, which contains the name of the fixture ``x``. The indirect parameter will be applied to this argument only, and the value ``a`` will be passed to respective fixture function:"
msgstr "多くの場合、パラメータ化には複数の引数名が使用されます。特定の引数に ``indirect`` パラメータを適用する機会があります。これは、引数名のリストまたはタプルを ``indirect`` に渡すことで行うことができます。以下の例では、``x`` と ``y`` の2つのフィクスチャを使用する ``test_indirect`` 関数があります。ここでは、フィクスチャ ``x`` の名前を含むリストを間接的に渡します。間接パラメータはこの引数にのみ適用され、値 ``a`` がそれぞれのフィクスチャ関数に渡されます："

#: ../../example/parametrize.rst:410
msgid "The result of this test will be successful:"
msgstr "このテストの結果は成功します："

#: ../../example/parametrize.rst:428
msgid "Parametrizing test methods through per-class configuration"
msgstr "クラスごとの構成を通じてテストメソッドをパラメータ化する"

#: ../../example/parametrize.rst:433
msgid "Here is an example ``pytest_generate_tests`` function implementing a parametrization scheme similar to Michael Foord's `unittest parametrizer`_ but in a lot less code:"
msgstr "ここに、Michael Foordの `unittest parametrizer`_ に似たパラメータ化スキームを実装する ``pytest_generate_tests`` 関数の例がありますが、コードははるかに少なくなっています："

#: ../../example/parametrize.rst:466
msgid "Our test generator looks up a class-level definition which specifies which argument sets to use for each test function.  Let's run it:"
msgstr "私たちのテストジェネレータは、各テスト関数に使用する引数セットを指定するクラスレベルの定義を検索します。実行してみましょう："

#: ../../example/parametrize.rst:488
msgid "Parametrization with multiple fixtures"
msgstr "複数のフィクスチャを使用したパラメータ化"

#: ../../example/parametrize.rst:490
msgid "Here is a stripped down real-life example of using parametrized testing for testing serialization of objects between different python interpreters.  We define a ``test_basic_objects`` function which is to be run with different sets of arguments for its three arguments:"
msgstr "ここに、異なるPythonインタープリタ間でオブジェクトのシリアル化をテストするためにパラメータ化されたテストを使用する実際の例があります。3つの引数に対して異なる引数セットで実行される ``test_basic_objects`` 関数を定義します："

#: ../../example/parametrize.rst:495
msgid "``python1``: first python interpreter, run to pickle-dump an object to a file"
msgstr "``python1``: 最初のPythonインタープリタ、オブジェクトをファイルにピクルダンプするために実行"

#: ../../example/parametrize.rst:496
msgid "``python2``: second interpreter, run to pickle-load an object from a file"
msgstr "``python2``: 2番目のインタープリタ、オブジェクトをファイルからピクルロードするために実行"

#: ../../example/parametrize.rst:497
msgid "``obj``: object to be dumped/loaded"
msgstr "``obj``: ダンプ/ロードされるオブジェクト"

#: ../../example/parametrize.rst:501
msgid "Running it results in some skips if we don't have all the python interpreters installed and otherwise runs all combinations (3 interpreters times 3 interpreters times 3 objects to serialize/deserialize):"
msgstr "すべてのPythonインタープリタがインストールされていない場合、実行するといくつかのスキップが発生し、それ以外の場合はすべての組み合わせ (3つのインタープリタ×3つのインタープリタ×3つのシリアル化/デシリアル化するオブジェクト) が実行されます："

#: ../../example/parametrize.rst:513
msgid "Parametrization of optional implementations/imports"
msgstr "オプションの実装/インポートのパラメータ化"

#: ../../example/parametrize.rst:515
msgid "If you want to compare the outcomes of several implementations of a given API, you can write test functions that receive the already imported implementations and get skipped in case the implementation is not importable/available.  Let's say we have a \"base\" implementation and the other (possibly optimized ones) need to provide similar results:"
msgstr "特定のAPIの複数の実装の結果を比較したい場合、すでにインポートされた実装を受け取り、実装がインポートできない/利用できない場合にスキップされるテスト関数を書くことができます。たとえば、「ベース」実装があり、他の (おそらく最適化された) 実装が同様の結果を提供する必要があるとします："

#: ../../example/parametrize.rst:537
msgid "And then a base implementation of a simple function:"
msgstr "次に、単純な関数のベース実装："

#: ../../example/parametrize.rst:545
msgid "And an optimized version:"
msgstr "そして最適化されたバージョン："

#: ../../example/parametrize.rst:553
msgid "And finally a little test module:"
msgstr "最後に小さなテストモジュール："

#: ../../example/parametrize.rst:564
msgid "If you run this with reporting for skips enabled:"
msgstr "スキップの報告を有効にしてこれを実行すると："

#: ../../example/parametrize.rst:580
msgid "You'll see that we don't have an ``opt2`` module and thus the second test run of our ``test_func1`` was skipped.  A few notes:"
msgstr "``opt2`` モジュールがないため、``test_func1`` の2回目のテスト実行がスキップされたことがわかります。いくつかの注意点："

#: ../../example/parametrize.rst:583
msgid "the fixture functions in the ``conftest.py`` file are \"session-scoped\" because we don't need to import more than once"
msgstr "``conftest.py`` ファイルのフィクスチャ関数は「セッションスコープ」です。インポートは1回だけで済むためです"

#: ../../example/parametrize.rst:586
msgid "if you have multiple test functions and a skipped import, you will see the ``[1]`` count increasing in the report"
msgstr "複数のテスト関数があり、インポートがスキップされた場合、レポートで ``[1]`` カウントが増加するのがわかります"

#: ../../example/parametrize.rst:589
msgid "you can put :ref:`@pytest.mark.parametrize <@pytest.mark.parametrize>` style parametrization on the test functions to parametrize input/output values as well."
msgstr "テスト関数に :ref:`@pytest.mark.parametrize <@pytest.mark.parametrize>` スタイルのパラメータ化を適用して、入力/出力値もパラメータ化できます。"

#: ../../example/parametrize.rst:595
msgid "Set marks or test ID for individual parametrized test"
msgstr "個々のパラメータ化されたテストにマークまたはテストIDを設定する"

#: ../../example/parametrize.rst:597
msgid "Use ``pytest.param`` to apply marks or set test ID to individual parametrized test. For example:"
msgstr "``pytest.param`` を使用して、個々のパラメータ化されたテストにマークを適用したり、テストIDを設定したりします。たとえば："

#: ../../example/parametrize.rst:620
msgid "In this example, we have 4 parametrized tests. Except for the first test, we mark the rest three parametrized tests with the custom marker ``basic``, and for the fourth test we also use the built-in mark ``xfail`` to indicate this test is expected to fail. For explicitness, we set test ids for some tests."
msgstr "この例では、4つのパラメータ化されたテストがあります。最初のテストを除いて、残りの3つのパラメータ化されたテストにはカスタムマーカー ``basic`` を付け、4番目のテストには組み込みのマーク ``xfail`` を使用して、このテストが失敗することを示します。明示的にするために、いくつかのテストにテストIDを設定します。"

#: ../../example/parametrize.rst:625
msgid "Then run ``pytest`` with verbose mode and with only the ``basic`` marker:"
msgstr "次に、詳細モードで ``pytest`` を実行し、``basic`` マーカーのみを使用します："

#: ../../example/parametrize.rst:642
msgid "As the result:"
msgstr "結果として："

#: ../../example/parametrize.rst:644
msgid "Four tests were collected"
msgstr "4つのテストが収集されました"

#: ../../example/parametrize.rst:645
msgid "One test was deselected because it doesn't have the ``basic`` mark."
msgstr "1つのテストは ``basic`` マークがないため、選択解除されました。"

#: ../../example/parametrize.rst:646
msgid "Three tests with the ``basic`` mark was selected."
msgstr "``basic`` マークの付いた3つのテストが選択されました。"

#: ../../example/parametrize.rst:647
msgid "The test ``test_eval[1+7-8]`` passed, but the name is autogenerated and confusing."
msgstr "テスト ``test_eval[1+7-8]`` は合格しましたが、名前は自動生成されており、混乱を招きます。"

#: ../../example/parametrize.rst:648
msgid "The test ``test_eval[basic_2+4]`` passed."
msgstr "テスト ``test_eval[basic_2+4]`` は合格しました。"

#: ../../example/parametrize.rst:649
msgid "The test ``test_eval[basic_6*9]`` was expected to fail and did fail."
msgstr "テスト ``test_eval[basic_6*9]`` は失敗することが予想され、実際に失敗しました。"

#: ../../example/parametrize.rst:654
msgid "Parametrizing conditional raising"
msgstr "条件付きの例外発生をパラメータ化する"

#: ../../example/parametrize.rst:656
msgid "Use :func:`pytest.raises` with the :ref:`pytest.mark.parametrize ref` decorator to write parametrized tests in which some tests raise exceptions and others do not."
msgstr ":func:`pytest.raises` を :ref:`pytest.mark.parametrize ref` デコレータと一緒に使用して、一部のテストが例外を発生させ、他のテストが発生させないパラメータ化されたテストを書きます。"

#: ../../example/parametrize.rst:660
msgid "``contextlib.nullcontext`` can be used to test cases that are not expected to raise exceptions but that should result in some value. The value is given as the ``enter_result`` parameter, which will be available as the ``with`` statement’s target (``e`` in the example below)."
msgstr "``contextlib.nullcontext`` を使用して、例外が発生しないが何らかの値を返すべきテストケースをテストできます。値は ``enter_result`` パラメータとして指定され、``with`` ステートメントのターゲット (以下の例では ``e``) として使用できます。"

#: ../../example/parametrize.rst:665
msgid "For example:"
msgstr "たとえば："

#: ../../example/parametrize.rst:688
msgid "In the example above, the first three test cases should run without any exceptions, while the fourth should raise a ``ZeroDivisionError`` exception, which is expected by pytest."
msgstr "上記の例では、最初の3つのテストケースは例外なしで実行されるべきですが、4番目のテストケースは ``ZeroDivisionError`` 例外を発生させるべきであり、これはpytestによって期待されます。"

